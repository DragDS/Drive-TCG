// bulk.js
// Bulk import (XLSX master): load -> filter -> select -> import.

import { AppState } from "./state.js";
import { Dom } from "./dom.js";
import { normalizeCardShape, generateId, parseTags, parseVehicleTypes, parseHpCon, refreshSingleUi } from "./single.js";

/************************************************************
 * Bulk session state
 ************************************************************/
let parsedCards = [];                // all cards extracted from XLSX
let selectedIds = new Set();         // card ids selected for import

let filterType = "";                // "" = all
let filterSet = "";                 // "" = all

/************************************************************
 * Helpers
 ************************************************************/
function normKey(str) {
  return (str || "")
    .toString()
    .trim()
    .toLowerCase()
    .replace(/[\s_]+/g, "")
    .replace(/[^\w]/g, "");
}

function str(v) {
  if (v === null || v === undefined) return "";
  return String(v).trim();
}

/**
 * Extract Set tokens from a "set field" that might look like:
 * - "SET 1"
 * - "SET 1 & 2 & 3"
 * - "SET 1 & SET 3"
 * - "Father's Day"
 * - "SET FATHERS DAY"
 */
function extractSetTokens(setField) {
  const s = str(setField);
  if (!s) return [];

  // Common case: "SET 1 & 2 & 3" or "SET 1 & SET 3"
  // First: pull all "SET ..." segments if present
  const hasSetWord = /set/i.test(s);

  if (hasSetWord) {
    // find things like "SET 1", "SET 2", "SET FATHERS DAY"
    const matches = s.match(/set\s*[a-z0-9' -]+/gi) || [];
    if (matches.length) {
      // Now also handle shorthand like "SET 1 & 2 & 3" (only first has SET)
      // If a match is exactly "SET 1", and the original string contains "& 2", add SET 2 etc.
      const tokens = [];

      // Add full matches
      matches.forEach(m => tokens.push(m.trim().toUpperCase()));

      // Shorthand expansion: if string starts with SET <x> and contains & <y>
      // Example: "SET 1 & 2 & 3"
      const first = tokens[0] || "";
      const firstPrefix = first.startsWith("SET ") ? "SET " : "";

      if (firstPrefix) {
        // capture standalone numbers/words separated by & after first token
        const tail = s
          .replace(/set\s*/i, "")
          .split("&")
          .map(t => t.trim())
          .filter(Boolean);

        // tail now like ["1", "2", "3"] or ["1", "SET 3"]
        tail.forEach(piece => {
          const cleaned = piece.replace(/^set\s*/i, "").trim();
          if (!cleaned) return;
          const full = `SET ${cleaned}`.toUpperCase();
          tokens.push(full);
        });
      }

      // De-dupe
      return Array.from(new Set(tokens)).filter(Boolean);
    }

    // If it contains SET but regex failed, just keep uppercase raw
    return [s.toUpperCase()];
  }

  // No "SET" word: treat as a single set name (e.g. "Father's Day")
  return [s.toUpperCase()];
}

/**
 * For a card, build its set label string and also tokens for filtering.
 * Uses prints if available; falls back to setName.
 */
function computeCardSetTokens(card) {
  const tokens = [];

  if (Array.isArray(card.prints) && card.prints.length) {
    card.prints.forEach(p => {
      extractSetTokens(p.setName || p.setId).forEach(t => tokens.push(t));
    });
  } else {
    extractSetTokens(card.setName).forEach(t => tokens.push(t));
  }

  return Array.from(new Set(tokens)).filter(Boolean);
}

function computeCardPrimarySetLabel(card) {
  const tokens = computeCardSetTokens(card);
  if (!tokens.length) return "SET ?";
  // keep a readable joined form
  return tokens.join(" & ");
}

function computeCardPrimaryNumber(card) {
  // prefer root cardNumber
  if (card.cardNumber) return card.cardNumber;
  // fall back to primary print number
  const p = (card.prints || []).find(x => x.isPrimary) || (card.prints || [])[0];
  return p?.cardNumber || "####";
}

function computeCardType(card) {
  return (card.type || "").trim() || "Misc";
}

function visibleCards() {
  return parsedCards.filter(card => {
    const t = computeCardType(card);
    const setTokens = computeCardSetTokens(card);

    const typeOk = !filterType || t === filterType;
    const setOk = !filterSet || setTokens.includes(filterSet);

    return typeOk && setOk;
  });
}

/************************************************************
 * Mapping XLSX rows -> cards
 ************************************************************/
function mapRowToCard(rowObj, sheetName) {
  const row = rowObj || {};
  const keys = Object.keys(row);
  const by = {};
  keys.forEach(k => { by[normKey(k)] = row[k]; });

  const get = (...names) => {
    for (const n of names) {
      const nk = normKey(n);
      if (nk in by) return str(by[nk]);
    }
    return "";
  };

  // Use explicit Type if present; else use sheet name (your workbook is per-type)
  const type = get("type") || str(sheetName);

  const name = get("name", "cardname", "title");
  const rarity = get("rarity", "rar");
  const notes = get("notes", "rules", "text", "effect");
  const imageUrl = get("imageurl", "image", "img", "art");
  const tagsStr = get("tags", "tag", "keywords");
  const vehicleTypesStr = get("vehicletype", "vehicletypes", "types");

  const setField = get("set", "setname", "prints", "print", "set(s)", "sets");
  const cardNumber = get("cardnumber", "number", "no", "#");

  // Build prints: if setField contains multiple sets, create a print for each token
  const setTokens = extractSetTokens(setField);
  const prints = setTokens.length
    ? setTokens.map((setNameTok, idx) => ({
        setName: setNameTok,
        cardNumber: cardNumber || "",
        isPrimary: idx === 0
      }))
    : (setField || cardNumber ? [{
        setName: setField ? setField.toUpperCase() : "",
        cardNumber: cardNumber || "",
        isPrimary: true
      }] : []);

  const vehicleTypes = parseVehicleTypes(vehicleTypesStr);
  const tags = parseTags(tagsStr);

  const extra = {};

  // Mod-specific columns
  if (type === "Mod") {
    extra.modBasePart = get("basepart", "part", "modbasepart");
    extra.modLevel1 = get("level1", "l1", "lvl1");
    extra.modLevel2 = get("level2", "l2", "lvl2");
    extra.modLevel3 = get("level3", "l3", "lvl3");
    extra.modLevel4 = get("level4", "l4", "lvl4");
  }

  // Vehicle stats
  if (type === "Vehicle" || type === "Named Vehicle") {
    const hpConStr = get("hpcon", "hp/con", "hpcon()", "hp", "hitpoints");
    if (hpConStr && hpConStr.includes("/")) {
      const hc = parseHpCon(hpConStr);
      extra.hp = hc.hp;
      extra.con = hc.con;
    } else {
      const hp = hpConStr ? Number(hpConStr) : undefined;
      extra.hp = Number.isFinite(hp) ? hp : undefined;
    }
    const pitStr = get("pitcost", "pit", "pitpoints");
    const pit = pitStr ? Number(pitStr) : undefined;
    extra.pitCost = Number.isFinite(pit) ? pit : undefined;
  }

  // ID: if sheet has one, keep it; otherwise deterministic-ish by name+type+number to reduce duplicates
  const idFromSheet = get("id", "cardid");
  const stableKey = `${type}__${name}__${cardNumber}`.toLowerCase().replace(/\s+/g, "_");
  const id = idFromSheet || (`card_${stableKey}`.slice(0, 60)) || generateId();

  const baseCard = {
    id,
    name,
    type,
    setName: setTokens[0] ? setTokens[0] : str(setField).toUpperCase(),
    cardNumber,
    rarity,
    vehicleTypes,
    tags,
    imageUrl,
    notes,
    extra,
    prints
  };

  // Skip empty rows
  const usable = (baseCard.name || baseCard.notes || baseCard.cardNumber || baseCard.tags.length || baseCard.vehicleTypes.length);
  if (!usable) return null;

  return normalizeCardShape(baseCard);
}

/************************************************************
 * UI rendering
 ************************************************************/
function rebuildFilterOptions() {
  if (!Dom.bulkTypeFilterSelect || !Dom.bulkSetFilterSelect) return;

  const types = new Set();
  const sets = new Set();

  parsedCards.forEach(c => {
    types.add(computeCardType(c));
    computeCardSetTokens(c).forEach(t => sets.add(t));
  });

  // Type select
  const typeSel = Dom.bulkTypeFilterSelect;
  typeSel.innerHTML = "";
  const optAllT = document.createElement("option");
  optAllT.value = "";
  optAllT.textContent = "All Types";
  typeSel.appendChild(optAllT);

  Array.from(types).sort((a,b) => a.localeCompare(b)).forEach(t => {
    const opt = document.createElement("option");
    opt.value = t;
    opt.textContent = t;
    typeSel.appendChild(opt);
  });

  // Set select (tokens)
  const setSel = Dom.bulkSetFilterSelect;
  setSel.innerHTML = "";
  const optAllS = document.createElement("option");
  optAllS.value = "";
  optAllS.textContent = "All Sets";
  setSel.appendChild(optAllS);

  Array.from(sets)
    .sort((a,b) => a.localeCompare(b, undefined, { numeric:true }))
    .forEach(s => {
      const opt = document.createElement("option");
      opt.value = s;
      opt.textContent = s; // already uppercased token
      setSel.appendChild(opt);
    });

  // keep current selections if possible
  typeSel.value = filterType;
  setSel.value = filterSet;
}

function renderCardList() {
  if (!Dom.bulkCardsList) return;
  const wrap = Dom.bulkCardsList;
  wrap.innerHTML = "";

  const cards = visibleCards();
  if (!cards.length) {
    const div = document.createElement("div");
    div.className = "bulk-status";
    div.textContent = "No cards match the current filters.";
    wrap.appendChild(div);
    return;
  }

  cards.forEach(card => {
    const line = document.createElement("label");
    line.className = "bulk-cardline";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = selectedIds.has(card.id);
    cb.addEventListener("change", () => {
      if (cb.checked) selectedIds.add(card.id);
      else selectedIds.delete(card.id);
      renderSelectedPreview();
    });

    const text = document.createElement("span");
    const t = computeCardType(card);
    const setLabel = computeCardPrimarySetLabel(card);
    const num = computeCardPrimaryNumber(card);
    text.textContent = `${t} | ${card.name || "(no name)"} | ${setLabel} #${num}`;

    line.appendChild(cb);
    line.appendChild(text);
    wrap.appendChild(line);
  });
}

function renderSelectedPreview() {
  if (!Dom.bulkSelectedPreview) return;

  const selected = parsedCards.filter(c => selectedIds.has(c.id));
  if (!selected.length) {
    Dom.bulkSelectedPreview.textContent = "No cards selected for import.";
    return;
  }

  const lines = selected.slice(0, 80).map(c => {
    const t = computeCardType(c);
    const setLabel = computeCardPrimarySetLabel(c);
    const num = computeCardPrimaryNumber(c);
    return `• ${t} | ${c.name || "(no name)"} | ${setLabel} #${num}`;
  });

  Dom.bulkSelectedPreview.textContent =
    `${selected.length} card(s) selected:\n` +
    lines.join("\n") +
    (selected.length > 80 ? `\n...and ${selected.length - 80} more.` : "");
}

/************************************************************
 * Actions
 ************************************************************/
function clearBulkSession() {
  parsedCards = [];
  selectedIds.clear();
  filterType = "";
  filterSet = "";

  if (Dom.bulkTypeFilterSelect) Dom.bulkTypeFilterSelect.innerHTML = `<option value="">All Types</option>`;
  if (Dom.bulkSetFilterSelect) Dom.bulkSetFilterSelect.innerHTML = `<option value="">All Sets</option>`;
  if (Dom.bulkCardsList) Dom.bulkCardsList.innerHTML = "";
  if (Dom.bulkSelectedPreview) Dom.bulkSelectedPreview.textContent = "No cards selected for import.";
  if (Dom.bulkStatus) Dom.bulkStatus.textContent = "Waiting for file…";
}

function handleImport() {
  const toImport = parsedCards.filter(c => selectedIds.has(c.id));
  if (!toImport.length) {
    if (Dom.bulkStatus) Dom.bulkStatus.textContent = "No cards selected to import.";
    return;
  }

  let added = 0;
  let updated = 0;

  toImport.forEach(card => {
    const idx = AppState.cards.findIndex(c => c.id === card.id);
    if (idx >= 0) {
      AppState.cards[idx] = card;
      updated++;
    } else {
      AppState.cards.push(card);
      added++;
    }
  });

  if (Dom.bulkStatus) {
    Dom.bulkStatus.textContent = `Imported ${toImport.length} card(s) (${added} added, ${updated} updated).`;
  }

  refreshSingleUi();
}

async function handleFileLoad(file) {
  if (!file) return;

  if (typeof XLSX === "undefined") {
    if (Dom.bulkStatus) Dom.bulkStatus.textContent = "XLSX library is missing. Check the XLSX script tag.";
    return;
  }

  const reader = new FileReader();

  reader.onerror = () => {
    if (Dom.bulkStatus) Dom.bulkStatus.textContent = "Could not read XLSX file.";
  };

  reader.onload = (e) => {
    try {
      const data = e.target.result;
      const wb = XLSX.read(data, { type: "array" });

      const all = [];

      wb.SheetNames.forEach(sheetName => {
        const sheet = wb.Sheets[sheetName];
        if (!sheet) return;

        // Row objects keyed by header names
        const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });

        rows.forEach(r => {
          const card = mapRowToCard(r, sheetName);
          if (card) all.push(card);
        });
      });

      parsedCards = all;
      selectedIds = new Set(parsedCards.map(c => c.id));

      rebuildFilterOptions();
      renderCardList();
      renderSelectedPreview();

      if (Dom.bulkStatus) Dom.bulkStatus.textContent = `Loaded ${parsedCards.length} card(s) from master XLSX.`;
    } catch (err) {
      console.error(err);
      if (Dom.bulkStatus) Dom.bulkStatus.textContent = "Failed to parse XLSX file.";
    }
  };

  reader.readAsArrayBuffer(file);
}

/************************************************************
 * Public init
 ************************************************************/
export function initBulk() {
  // File input
  if (Dom.bulkMasterFileInput) {
    Dom.bulkMasterFileInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      handleFileLoad(file);
    });
  }

  // Filters
  if (Dom.bulkTypeFilterSelect) {
    Dom.bulkTypeFilterSelect.addEventListener("change", () => {
      filterType = Dom.bulkTypeFilterSelect.value || "";
      renderCardList();
    });
  }
  if (Dom.bulkSetFilterSelect) {
    Dom.bulkSetFilterSelect.addEventListener("change", () => {
      filterSet = Dom.bulkSetFilterSelect.value || "";
      renderCardList();
    });
  }

  // Select/Deselect viewed
  if (Dom.bulkSelectAllViewedBtn) {
    Dom.bulkSelectAllViewedBtn.addEventListener("click", () => {
      visibleCards().forEach(c => selectedIds.add(c.id));
      renderCardList();
      renderSelectedPreview();
    });
  }
  if (Dom.bulkDeselectAllViewedBtn) {
    Dom.bulkDeselectAllViewedBtn.addEventListener("click", () => {
      visibleCards().forEach(c => selectedIds.delete(c.id));
      renderCardList();
      renderSelectedPreview();
    });
  }

  // Import / Clear
  if (Dom.bulkImportBtn) Dom.bulkImportBtn.addEventListener("click", handleImport);
  if (Dom.bulkClearBtn) Dom.bulkClearBtn.addEventListener("click", clearBulkSession);

  // Initial
  clearBulkSession();
}
