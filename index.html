<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DRIVE TCG â€“ Card Library & Deck Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }
    body {
      margin: 0;
      background: #020617;
      color: #e5e7eb;
    }
    .app {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: baseline;
      margin-bottom: 0.75rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.7rem;
    }
    header small {
      font-size: 0.8rem;
      color: #9ca3af;
    }
    .header-right {
      margin-left: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
    }
    @media (max-width: 800px) {
      .header-right {
        margin-left: 0;
        align-items: flex-start;
      }
    }

    .mode-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .mode-label {
      font-size: 0.8rem;
      color: #9ca3af;
    }
    .mode-btn {
      border-radius: 999px;
      padding: 0.3rem 0.9rem;
      font-size: 0.8rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      cursor: pointer;
      transition: background 0.1s ease, border-color 0.1s ease,
        box-shadow 0.1s ease, transform 0.05s ease;
    }
    .mode-btn:hover {
      background: #030712;
      box-shadow: 0 6px 14px rgba(0,0,0,0.4);
    }
    .mode-btn.active {
      border-color: #22c55e;
      background: rgba(34,197,94,0.08);
      box-shadow: 0 0 0 1px rgba(34,197,94,0.35);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 2.1fr) minmax(0, 1.6fr);
      gap: 1rem;
    }
    @media (max-width: 900px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid #1f2937;
      padding: 0.75rem;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }

    .panel h2 {
      margin: 0 0 0.5rem;
      font-size: 1.05rem;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    input[type="text"],
    select {
      padding: 0.4rem 0.6rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.85rem;
    }
    input[type="text"] {
      min-width: 0;
      flex: 1;
    }

    .small-note {
      font-size: 0.76rem;
      color: #9ca3af;
      margin-top: 0.15rem;
    }

    /* Card grid */
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    .card-tile {
      background: radial-gradient(circle at top, #0f172a, #020617);
      border-radius: 0.75rem;
      border: 1px solid #1f2937;
      padding: 0.4rem 0.5rem 0.5rem;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      box-shadow: 0 8px 20px rgba(0,0,0,0.55);
      position: relative;
      overflow: hidden;
    }
    .card-tile:hover {
      border-color: #22c55e;
      box-shadow: 0 0 0 1px rgba(34,197,94,0.35), 0 12px 30px rgba(0,0,0,0.7);
      transform: translateY(-1px);
    }
    .card-image-wrapper {
      border-radius: 0.5rem;
      overflow: hidden;
      border: 1px solid #111827;
      background: #020617;
      min-height: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .card-image-wrapper img {
      display: block;
      max-width: 100%;
      max-height: 220px;
      object-fit: contain;
    }
    .card-name {
      font-size: 0.88rem;
      font-weight: 600;
      margin-top: 0.25rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .card-subinfo {
      font-size: 0.72rem;
      color: #9ca3af;
      display: flex;
      justify-content: space-between;
      gap: 0.25rem;
    }
    .card-type-pill {
      font-size: 0.7rem;
      padding: 0.05rem 0.45rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: rgba(15,23,42,0.85);
      white-space: nowrap;
      max-width: 60%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .precon-qty-badge {
      position: absolute;
      top: 0.3rem;
      right: 0.4rem;
      font-size: 0.75rem;
      background: rgba(15,118,110,0.9);
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      border: 1px solid rgba(34,211,238,0.8);
    }

    /* Deck builder / Precon deck list */
    .deck-header-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    .deck-select {
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.85rem;
    }
    textarea.deck-notes {
      width: 100%;
      padding: 0.4rem 0.6rem;
      border-radius: 0.5rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.85rem;
      resize: vertical;
      min-height: 3rem;
    }

    .deck-list {
      border-radius: 0.5rem;
      border: 1px solid #1f2937;
      padding: 0.4rem;
      font-size: 0.78rem;
      max-height: 360px;
      overflow-y: auto;
      background: #020617;
      margin-top: 0.35rem;
    }
    .deck-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.35rem;
      padding: 0.15rem 0.2rem;
      border-radius: 0.4rem;
    }
    .deck-row:nth-child(odd) {
      background: rgba(15,23,42,0.6);
    }
    .deck-row:nth-child(even) {
      background: rgba(15,23,42,0.3);
    }
    .deck-row-info {
      flex: 1;
      min-width: 0;
    }
    .deck-row-main {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .deck-row-sub {
      font-size: 0.7rem;
      color: #9ca3af;
    }
    .deck-row-qty {
      display: flex;
      align-items: center;
      gap: 0.2rem;
      flex-shrink: 0;
    }
    .deck-qty-number {
      min-width: 1.2rem;
      text-align: center;
      font-size: 0.8rem;
    }
    .deck-btn {
      border-radius: 999px;
      border: 1px solid #374151;
      background: #111827;
      color: #e5e7eb;
      padding: 0.05rem 0.4rem;
      font-size: 0.75rem;
      cursor: pointer;
    }
    .deck-btn:hover {
      background: #020617;
    }

    .status-ok {
      color: #4ade80;
    }
    .status-bad {
      color: #f97373;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.8rem;
      font-size: 0.85rem;
      cursor: pointer;
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #374151;
      transition: background 0.1s ease, transform 0.05s ease,
        box-shadow 0.1s ease;
    }
    button:hover {
      background: #020617;
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0,0,0,0.45);
    }
    button.secondary {
      background: #020617;
    }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }
    .modal {
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid #1f2937;
      max-width: 760px;
      width: 100%;
      max-height: 90vh;
      overflow: hidden;
      box-shadow: 0 25px 60px rgba(0,0,0,0.7);
      display: grid;
      grid-template-columns: minmax(0,1.1fr) minmax(0,1.3fr);
      gap: 0;
    }
    @media (max-width: 800px) {
      .modal {
        grid-template-columns: minmax(0,1fr);
      }
    }
    .modal-image {
      padding: 0.6rem;
      border-right: 1px solid #111827;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #0f172a, #020617);
    }
    .modal-image img {
      max-width: 100%;
      max-height: 80vh;
      object-fit: contain;
      border-radius: 0.5rem;
      border: 1px solid #111827;
    }
    .modal-body {
      padding: 0.75rem 0.85rem 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .modal-header-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.5rem;
    }
    .modal-title {
      font-size: 1rem;
      font-weight: 600;
    }
    .modal-chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      font-size: 0.75rem;
      color: #9ca3af;
    }
    .modal-chip {
      border-radius: 999px;
      padding: 0.05rem 0.45rem;
      border: 1px solid #374151;
      background: #020617;
    }
    .modal-notes {
      font-size: 0.8rem;
      line-height: 1.4;
      margin-top: 0.15rem;
    }
    .modal-footer {
      margin-top: auto;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 0.4rem;
      align-items: center;
      font-size: 0.8rem;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>DRIVE TCG â€“ Card Library</h1>
        <small>Browse official cards, build your own decks, or view preconstructed decks.</small>
      </div>
      <div class="header-right">
        <div class="mode-toggle">
          <span class="mode-label">Mode:</span>
          <button id="modeCardsBtn" class="mode-btn active">Cards & Deck Builder</button>
          <button id="modePreconsBtn" class="mode-btn">Precon Viewer</button>
        </div>
        <small id="dataStatus" class="small-note"></small>
      </div>
    </header>

    <div class="layout">
      <!-- LEFT: Card browser -->
      <section class="panel">
        <h2>Card Browser</h2>
        <div class="toolbar">
          <input id="searchInput" type="text" placeholder="Search by name, type, textâ€¦" />
          <select id="typeFilter">
            <option value="">All Types</option>
            <option value="Crew">Crew</option>
            <option value="Driver">Driver</option>
            <option value="Named Driver">Named Driver</option>
            <option value="Vehicle">Vehicle</option>
            <option value="Named Vehicle">Named Vehicle</option>
            <option value="Mod">Mod</option>
            <option value="Track">Track</option>
            <option value="Condition">Condition</option>
          </select>
          <select id="setFilter">
            <option value="">All Sets</option>
          </select>
        </div>
        <div id="modeHint" class="small-note"></div>
        <div id="cardGrid" class="card-grid"></div>
      </section>

      <!-- RIGHT: Deck builder / Precon viewer -->
      <section class="panel">
        <!-- Deck builder panel (Cards mode) -->
        <div id="deckPanel">
          <h2>Deck Builder</h2>
          <div class="deck-header-row">
            <select id="deckSelect" class="deck-select"></select>
            <button id="newDeckBtn" type="button">+ New Deck</button>
            <button id="duplicateDeckBtn" type="button" class="secondary">ðŸ“„ Duplicate</button>
            <button id="deleteDeckBtn" type="button">ðŸ—‘ Delete</button>
          </div>
          <div class="field">
            <input id="deckNameInput" type="text" placeholder="Deck name" style="width:100%; padding:0.4rem 0.6rem; border-radius:0.5rem; border:1px solid #374151; background:#020617; color:#e5e7eb; font-size:0.85rem;" />
          </div>

          <div id="deckStats" class="small-note"></div>
          <div id="deckLegality" class="small-note" style="margin-top:0.2rem;"></div>

          <div id="deckList" class="deck-list" style="margin-top:0.35rem;"></div>

          <div style="margin-top:0.5rem; display:flex; flex-wrap:wrap; gap:0.4rem;">
            <button id="exportDeckTxtBtn" type="button" class="secondary">Export Deck (TXT)</button>
            <button id="exportDeckJsonBtn" type="button" class="secondary">Export Deck (JSON)</button>
          </div>
        </div>

        <!-- Precon viewer panel (Precon mode) -->
        <div id="preconPanel" class="hidden">
          <h2>Precon Decks</h2>
          <div class="deck-header-row">
            <select id="preconSelect" class="deck-select"></select>
          </div>
          <div id="preconNotes" class="small-note"></div>
          <div id="preconStats" class="small-note" style="margin-top:0.3rem;"></div>
          <div id="preconList" class="deck-list" style="margin-top:0.35rem;"></div>
          <div class="small-note" style="margin-top:0.3rem;">
            In Precon Viewer mode, the card grid shows only the cards from the selected precon. Click a card to view full details.
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Card modal -->
  <div id="modalBackdrop" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-image">
        <img id="modalImage" src="" alt="Card image" />
      </div>
      <div class="modal-body">
        <div class="modal-header-row">
          <div>
            <div id="modalTitle" class="modal-title"></div>
            <div id="modalSubchips" class="modal-chip-row"></div>
          </div>
          <button id="modalCloseBtn" type="button">âœ•</button>
        </div>
        <div id="modalNotes" class="modal-notes"></div>

        <div id="modalExtra" class="small-note"></div>

        <div class="modal-footer">
          <div id="modalDeckControls" class="small-note"></div>
          <div class="small-note" id="modalHint"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let cards = [];
    let cardMap = {};
    let precons = [];
    let mode = "cards"; // "cards" or "precons"

    // Deck builder data
    const DECKS_KEY = "driveDecks_v1";
    let decks = [];
    let activeDeckIndex = 0;

    // Precon viewer
    let activePreconIndex = 0;

    // DOM refs
    const modeCardsBtn = document.getElementById("modeCardsBtn");
    const modePreconsBtn = document.getElementById("modePreconsBtn");
    const deckPanel = document.getElementById("deckPanel");
    const preconPanel = document.getElementById("preconPanel");
    const dataStatus = document.getElementById("dataStatus");

    const searchInput = document.getElementById("searchInput");
    const typeFilter = document.getElementById("typeFilter");
    const setFilter = document.getElementById("setFilter");
    const cardGrid = document.getElementById("cardGrid");
    const modeHint = document.getElementById("modeHint");

    // Deck UI
    const deckSelect = document.getElementById("deckSelect");
    const newDeckBtn = document.getElementById("newDeckBtn");
    const duplicateDeckBtn = document.getElementById("duplicateDeckBtn");
    const deleteDeckBtn = document.getElementById("deleteDeckBtn");
    const deckNameInput = document.getElementById("deckNameInput");
    const deckList = document.getElementById("deckList");
    const deckStats = document.getElementById("deckStats");
    const deckLegality = document.getElementById("deckLegality");
    const exportDeckTxtBtn = document.getElementById("exportDeckTxtBtn");
    const exportDeckJsonBtn = document.getElementById("exportDeckJsonBtn");

    // Precon UI
    const preconSelect = document.getElementById("preconSelect");
    const preconNotes = document.getElementById("preconNotes");
    const preconStats = document.getElementById("preconStats");
    const preconList = document.getElementById("preconList");

    // Modal
    const modalBackdrop = document.getElementById("modalBackdrop");
    const modalImage = document.getElementById("modalImage");
    const modalTitle = document.getElementById("modalTitle");
    const modalSubchips = document.getElementById("modalSubchips");
    const modalNotes = document.getElementById("modalNotes");
    const modalExtra = document.getElementById("modalExtra");
    const modalDeckControls = document.getElementById("modalDeckControls");
    const modalHint = document.getElementById("modalHint");
    const modalCloseBtn = document.getElementById("modalCloseBtn");

    let modalCardId = null;

    // ---------- Data loading ----------

    async function loadData() {
      let cardOk = false;
      let preconOk = false;
      try {
        const res = await fetch("drive-card.json", { cache: "no-store" });
        if (res.ok) {
          const json = await res.json();
          if (Array.isArray(json)) {
            cards = json;
            cards.forEach(c => { if (c.id) cardMap[c.id] = c; });
            cardOk = true;
          }
        }
      } catch (e) {
        console.error("Error loading drive-card.json", e);
      }

      try {
        const res = await fetch("drive-precons.json", { cache: "no-store" });
        if (res.ok) {
          const json = await res.json();
          if (Array.isArray(json)) {
            precons = json;
            preconOk = true;
          }
        }
      } catch (e) {
        console.warn("No drive-precons.json found (precon viewer will be empty).");
      }

      // Status text
      let parts = [];
      parts.push(cardOk ? "Cards loaded" : "Cards missing");
      parts.push(preconOk ? "Precons loaded" : "No precons file");
      dataStatus.textContent = parts.join(" Â· ");

      buildSetFilter();
      initDecks();
      renderDeckUI();
      buildPreconSelect();
      renderPreconUI();
      renderCards();
    }

    function buildSetFilter() {
      const sets = Array.from(
        new Set(cards.map(c => c.setName).filter(Boolean))
      ).sort((a,b) => a.localeCompare(b));
      setFilter.innerHTML = '<option value="">All Sets</option>';
      sets.forEach(setName => {
        const opt = document.createElement("option");
        opt.value = setName;
        opt.textContent = setName;
        setFilter.appendChild(opt);
      });
    }

    // ---------- Card grid rendering ----------

    function cardMatchesFilters(card) {
      const q = searchInput.value.trim().toLowerCase();
      const type = typeFilter.value;
      const set = setFilter.value;

      if (type && card.type !== type) return false;
      if (set && card.setName !== set) return false;

      if (q) {
        const blob = (
          (card.name || "") + " " +
          (card.type || "") + " " +
          (card.setName || "") + " " +
          (card.cardNumber || "") + " " +
          (card.notes || "")
        ).toLowerCase();
        if (!blob.includes(q)) return false;
      }

      // Precon mode: only show cards in active precon
      if (mode === "precons" && precons.length) {
        const p = precons[activePreconIndex];
        if (!p || !p.cards) return false;
        if (!p.cards[card.id]) return false;
      }

      return true;
    }

    function renderCards() {
      cardGrid.innerHTML = "";
      let list = cards.filter(cardMatchesFilters);

      if (!list.length) {
        cardGrid.innerHTML = "<div class='small-note'>No cards match the current filters.</div>";
        return;
      }

      let hintText = "";
      if (mode === "cards") {
        hintText = "Click a card to view it, then use the +/âˆ’ controls in the popup to add it to your active deck.";
      } else {
        const p = precons[activePreconIndex];
        hintText = p
          ? `Showing cards from precon: â€œ${p.name || "Unnamed Precon"}â€.`
          : "No precons found. Add a drive-precons.json file to enable Precon Viewer.";
      }
      modeHint.textContent = hintText;

      const activePrecon = mode === "precons" && precons.length
        ? precons[activePreconIndex]
        : null;

      list.forEach(card => {
        const tile = document.createElement("div");
        tile.className = "card-tile";
        tile.dataset.cardId = card.id || "";

        const imgWrap = document.createElement("div");
        imgWrap.className = "card-image-wrapper";
        const img = document.createElement("img");
        img.src = card.imageData || "";
        img.alt = card.name || "Card image";
        imgWrap.appendChild(img);

        const nameDiv = document.createElement("div");
        nameDiv.className = "card-name";
        nameDiv.textContent = card.name || "(No Name)";

        const sub = document.createElement("div");
        sub.className = "card-subinfo";

        const typePill = document.createElement("div");
        typePill.className = "card-type-pill";
        typePill.textContent = card.type || "";

        const rightInfo = document.createElement("div");
        rightInfo.style.textAlign = "right";
        rightInfo.innerHTML =
          (card.setName || "") +
          (card.cardNumber ? `<br />#${card.cardNumber}` : "");

        sub.appendChild(typePill);
        sub.appendChild(rightInfo);

        tile.appendChild(imgWrap);
        tile.appendChild(nameDiv);
        tile.appendChild(sub);

        // If in precon mode, show quantity badge
        if (activePrecon && activePrecon.cards && activePrecon.cards[card.id]) {
          const qty = activePrecon.cards[card.id];
          const badge = document.createElement("div");
          badge.className = "precon-qty-badge";
          badge.textContent = `x${qty}`;
          tile.appendChild(badge);
        }

        tile.addEventListener("click", () => openModal(card.id));
        cardGrid.appendChild(tile);
      });
    }

    // ---------- Deck builder logic ----------

    function initDecks() {
      try {
        const raw = localStorage.getItem(DECKS_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed) && parsed.length) {
            decks = parsed;
          }
        }
      } catch {
        // ignore
      }
      if (!decks.length) {
        decks = [
          { name: "Deck 1", cards: {} },
          { name: "Deck 2", cards: {} },
          { name: "Deck 3", cards: {} },
        ];
      }
      activeDeckIndex = 0;
      populateDeckSelect();
    }

    function populateDeckSelect() {
      deckSelect.innerHTML = "";
      decks.forEach((d, i) => {
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = d.name || `Deck ${i+1}`;
        deckSelect.appendChild(opt);
      });
      deckSelect.value = String(activeDeckIndex);
      deckNameInput.value = decks[activeDeckIndex].name || "";
    }

    function saveDecks() {
      localStorage.setItem(DECKS_KEY, JSON.stringify(decks));
    }

    function analyzeDeck(deck) {
      const counts = deck.cards || {};
      let total = 0;
      let typeCounts = {};
      let problems = [];

      for (const [cardId, countRaw] of Object.entries(counts)) {
        const card = cardMap[cardId];
        if (!card) continue;
        const count = Number(countRaw) || 0;
        if (count <= 0) continue;

        total += count;
        typeCounts[card.type] = (typeCounts[card.type] || 0) + count;

        const isNamed = card.type && card.type.startsWith("Named");
        const maxCopies = isNamed ? 1 : 4;
        if (count > maxCopies) {
          problems.push(`${card.name}: max ${maxCopies} copies`);
        }
      }

      const vehicleCount =
        (typeCounts["Vehicle"] || 0) + (typeCounts["Named Vehicle"] || 0);

      const sizeOk = total === 50;
      const vehicleOk = vehicleCount >= 2;
      const copiesOk = problems.length === 0;

      const legal = sizeOk && vehicleOk && copiesOk;

      return {
        total,
        typeCounts,
        vehicleCount,
        sizeOk,
        vehicleOk,
        copiesOk,
        problems,
        legal
      };
    }

    function renderDeckUI() {
      const deck = decks[activeDeckIndex];
      if (!deck) return;

      deckNameInput.value = deck.name || "";

      const analysis = analyzeDeck(deck);
      const { total, typeCounts, vehicleCount, sizeOk, vehicleOk, copiesOk, problems, legal } = analysis;

      const orderedTypes = [
        "Vehicle",
        "Named Vehicle",
        "Driver",
        "Named Driver",
        "Crew",
        "Mod",
        "Track",
        "Condition"
      ];
      let parts = [];
      orderedTypes.forEach(t => {
        if (typeCounts[t]) parts.push(`${t}: ${typeCounts[t]}`);
      });
      Object.keys(typeCounts).forEach(t => {
        if (!orderedTypes.includes(t)) parts.push(`${t}: ${typeCounts[t]}`);
      });

      deckStats.textContent =
        `Total cards: ${total} Â· Vehicles: ${vehicleCount}` +
        (parts.length ? " Â· " + parts.join(" Â· ") : "");

      if (legal) {
        deckLegality.innerHTML = `<span class="status-ok">âœ” Deck is legal for DRIVE (50 cards, max 4 copies, 1 per Named card, at least 2 Vehicles).</span>`;
      } else {
        let lines = [];
        if (!sizeOk) lines.push("Deck must contain exactly 50 cards.");
        if (!vehicleOk) lines.push("Deck must contain at least 2 Vehicle / Named Vehicle cards.");
        if (!copiesOk) lines.push("Some cards exceed their copy limits.");
        if (problems.length) {
          lines.push("Copy issues: " + problems.join("; "));
        }
        deckLegality.innerHTML = `<span class="status-bad">âœ– Deck is not legal:</span> ${lines.join(" ")}`;
      }

      // Deck list
      deckList.innerHTML = "";
      const entries = Object.entries(deck.cards || {})
        .filter(([,count]) => count > 0)
        .sort(([aId],[bId]) => {
          const a = cardMap[aId];
          const b = cardMap[bId];
          if (!a || !b) return 0;
          return (a.type || "").localeCompare(b.type || "") ||
                 (a.name || "").localeCompare(b.name || "");
        });

      if (!entries.length) {
        deckList.innerHTML = "<div class='small-note'>No cards in this deck yet. In Cards mode, click a card then use the + button in the popup to add it.</div>";
        return;
      }

      entries.forEach(([cardId, count]) => {
        const card = cardMap[cardId];
        if (!card) return;
        const row = document.createElement("div");
        row.className = "deck-row";

        const info = document.createElement("div");
        info.className = "deck-row-info";

        const main = document.createElement("div");
        main.className = "deck-row-main";
        main.textContent = `${count}x ${card.name}`;

        const sub = document.createElement("div");
        sub.className = "deck-row-sub";
        const setLabel = card.setName || "";
        const num = card.cardNumber ? ` #${card.cardNumber}` : "";
        sub.textContent = `[${card.type}] ${setLabel}${num}`;

        info.appendChild(main);
        info.appendChild(sub);

        const qty = document.createElement("div");
        qty.className = "deck-row-qty";

        const minusBtn = document.createElement("button");
        minusBtn.className = "deck-btn";
        minusBtn.textContent = "âˆ’";
        minusBtn.onclick = () => {
          changeDeckCardCount(cardId, -1);
        };

        const number = document.createElement("span");
        number.className = "deck-qty-number";
        number.textContent = String(count);

        const plusBtn = document.createElement("button");
        plusBtn.className = "deck-btn";
        plusBtn.textContent = "+";
        plusBtn.onclick = () => {
          changeDeckCardCount(cardId, +1);
        };

        qty.appendChild(minusBtn);
        qty.appendChild(number);
        qty.appendChild(plusBtn);

        row.appendChild(info);
        row.appendChild(qty);

        row.addEventListener("click", (e) => {
          if (e.target.tagName.toLowerCase() === "button") return;
          openModal(cardId);
        });

        deckList.appendChild(row);
      });
    }

    function changeDeckCardCount(cardId, delta) {
      const deck = decks[activeDeckIndex];
      if (!deck) return;
      const card = cardMap[cardId];
      if (!card) return;

      const isNamed = card.type && card.type.startsWith("Named");
      const maxCopies = isNamed ? 1 : 4;

      const current = deck.cards[cardId] || 0;
      let next = current + delta;
      if (next < 0) next = 0;
      if (next > maxCopies) next = maxCopies;

      deck.cards[cardId] = next;
      if (deck.cards[cardId] === 0) delete deck.cards[cardId];

      saveDecks();
      renderDeckUI();
    }

    // deck events
    deckSelect.addEventListener("change", () => {
      activeDeckIndex = Number(deckSelect.value) || 0;
      deckNameInput.value = decks[activeDeckIndex].name || "";
      renderDeckUI();
    });

    deckNameInput.addEventListener("input", () => {
      const d = decks[activeDeckIndex];
      if (!d) return;
      d.name = deckNameInput.value;
      saveDecks();
      populateDeckSelect();
    });

    newDeckBtn.addEventListener("click", () => {
      const name = prompt("Name for the new deck?", `Deck ${decks.length + 1}`);
      if (!name) return;
      decks.push({ name, cards: {} });
      activeDeckIndex = decks.length - 1;
      saveDecks();
      populateDeckSelect();
      renderDeckUI();
    });

    duplicateDeckBtn.addEventListener("click", () => {
      const d = decks[activeDeckIndex];
      if (!d) {
        alert("No deck selected.");
        return;
      }
      const copy = {
        name: d.name + " (Copy)",
        cards: { ...d.cards }
      };
      decks.push(copy);
      activeDeckIndex = decks.length - 1;
      saveDecks();
      populateDeckSelect();
      renderDeckUI();
    });

    deleteDeckBtn.addEventListener("click", () => {
      if (!decks.length) return;
      const d = decks[activeDeckIndex];
      if (!confirm(`Delete deck "${d.name}"?`)) return;

      if (decks.length === 1) {
        decks[0] = { name: "Deck 1", cards: {} };
        activeDeckIndex = 0;
      } else {
        decks.splice(activeDeckIndex, 1);
        if (activeDeckIndex >= decks.length) activeDeckIndex = decks.length - 1;
      }
      saveDecks();
      populateDeckSelect();
      renderDeckUI();
    });

    function exportDeckAsText() {
      const deck = decks[activeDeckIndex];
      if (!deck) return;
      const lines = [];
      lines.push(`Deck: ${deck.name || ""}`);
      lines.push("");

      const entries = Object.entries(deck.cards || {})
        .filter(([,count]) => count > 0)
        .sort(([aId],[bId]) => {
          const a = cardMap[aId];
          const b = cardMap[bId];
          if (!a || !b) return 0;
          return (a.type || "").localeCompare(b.type || "") ||
                 (a.name || "").localeCompare(b.name || "");
        });

      entries.forEach(([cardId, count]) => {
        const card = cardMap[cardId];
        if (!card) return;
        const setLabel = card.setName || "";
        const num = card.cardNumber ? ` #${card.cardNumber}` : "";
        lines.push(`${count}x ${card.name} [${card.type}] ${setLabel}${num}`);
      });

      const blob = new Blob([lines.join("\n")], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = (deck.name || "deck") + ".txt";
      a.click();
      URL.revokeObjectURL(url);
    }

    function exportDeckAsJson() {
      const deck = decks[activeDeckIndex];
      if (!deck) return;
      const blob = new Blob([JSON.stringify(deck, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = (deck.name || "deck") + ".json";
      a.click();
      URL.revokeObjectURL(url);
    }

    exportDeckTxtBtn.addEventListener("click", exportDeckAsText);
    exportDeckJsonBtn.addEventListener("click", exportDeckAsJson);

    // ---------- Precon viewer ----------

    function buildPreconSelect() {
      preconSelect.innerHTML = "";
      if (!precons.length) {
        const opt = document.createElement("option");
        opt.value = "0";
        opt.textContent = "No precons available";
        preconSelect.appendChild(opt);
        preconSelect.disabled = true;
        return;
      }
      preconSelect.disabled = false;
      precons.forEach((p, idx) => {
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = p.name || `Precon ${idx + 1}`;
        preconSelect.appendChild(opt);
      });
      activePreconIndex = Math.min(activePreconIndex, precons.length - 1);
      preconSelect.value = String(activePreconIndex);
    }

    function renderPreconUI() {
      if (!precons.length) {
        preconNotes.textContent = "No precons found. Add drive-precons.json alongside drive-card.json to enable this view.";
        preconStats.textContent = "";
        preconList.innerHTML = "";
        return;
      }
      const p = precons[activePreconIndex];
      if (!p) return;

      preconNotes.textContent = p.notes || "";
      const entries = Object.entries(p.cards || {})
        .filter(([,count]) => count > 0)
        .sort(([aId],[bId]) => {
          const a = cardMap[aId];
          const b = cardMap[bId];
          if (!a || !b) return 0;
          return (a.type || "").localeCompare(b.type || "") ||
                 (a.name || "").localeCompare(b.name || "");
        });

      let total = 0;
      let typeCounts = {};
      entries.forEach(([cardId, count]) => {
        const card = cardMap[cardId];
        if (!card) return;
        const n = Number(count) || 0;
        total += n;
        typeCounts[card.type] = (typeCounts[card.type] || 0) + n;
      });

      const orderedTypes = [
        "Vehicle","Named Vehicle","Driver","Named Driver","Crew","Mod","Track","Condition"
      ];
      let parts = [];
      orderedTypes.forEach(t => {
        if (typeCounts[t]) parts.push(`${t}: ${typeCounts[t]}`);
      });
      Object.keys(typeCounts).forEach(t => {
        if (!orderedTypes.includes(t)) parts.push(`${t}: ${typeCounts[t]}`);
      });

      preconStats.textContent =
        `Total cards: ${total}` +
        (parts.length ? " Â· " + parts.join(" Â· ") : "");

      preconList.innerHTML = "";
      if (!entries.length) {
        preconList.innerHTML = "<div class='small-note'>This precon has no cards defined yet.</div>";
        return;
      }

      entries.forEach(([cardId, count]) => {
        const card = cardMap[cardId];
        if (!card) return;
        const row = document.createElement("div");
        row.className = "deck-row";

        const info = document.createElement("div");
        info.className = "deck-row-info";

        const main = document.createElement("div");
        main.className = "deck-row-main";
        main.textContent = `${count}x ${card.name}`;

        const sub = document.createElement("div");
        sub.className = "deck-row-sub";
        const setLabel = card.setName || "";
        const num = card.cardNumber ? ` #${card.cardNumber}` : "";
        sub.textContent = `[${card.type}] ${setLabel}${num}`;

        info.appendChild(main);
        info.appendChild(sub);

        const qty = document.createElement("div");
        qty.className = "deck-row-qty";

        const number = document.createElement("span");
        number.className = "deck-qty-number";
        number.textContent = String(count);

        qty.appendChild(number);

        row.appendChild(info);
        row.appendChild(qty);

        row.addEventListener("click", () => openModal(cardId));
        preconList.appendChild(row);
      });
    }

    preconSelect.addEventListener("change", () => {
      activePreconIndex = Number(preconSelect.value) || 0;
      renderPreconUI();
      renderCards();
    });

    // ---------- Modal logic ----------

    function openModal(cardId) {
      const card = cardMap[cardId] || cards.find(c => c.id === cardId);
      if (!card) return;
      modalCardId = cardId;

      modalImage.src = card.imageData || "";
      modalTitle.textContent = card.name || "(No Name)";
      modalSubchips.innerHTML = "";

      const typeChip = document.createElement("div");
      typeChip.className = "modal-chip";
      typeChip.textContent = card.type || "";
      modalSubchips.appendChild(typeChip);

      if (card.setName) {
        const setChip = document.createElement("div");
        setChip.className = "modal-chip";
        setChip.textContent = `${card.setName}${card.cardNumber ? " Â· #" + card.cardNumber : ""}`;
        modalSubchips.appendChild(setChip);
      }

      if (card.rarity) {
        const rChip = document.createElement("div");
        rChip.className = "modal-chip";
        rChip.textContent = card.rarity;
        modalSubchips.appendChild(rChip);
      }

      modalNotes.textContent = card.notes || "";

      // extra info (vehicle types, HP/CON, mod levels)
      const extra = card.extra || {};
      let extraParts = [];

      if (Array.isArray(extra.vehicleTypes) && extra.vehicleTypes.length) {
        extraParts.push("Vehicle Types: " + extra.vehicleTypes.join(", "));
      }
      if (extra.vehicleType) {
        extraParts.push("Vehicle Type: " + extra.vehicleType);
      }
      if (extra.hp != null || extra.con != null) {
        extraParts.push(`HP/CON: ${extra.hp ?? "-"} / ${extra.con ?? "-"}`);
      }
      if (card.type === "Mod") {
        if (extra.modBasePart) extraParts.push("Base Part: " + extra.modBasePart);
        const lvls = [];
        if (extra.modLevel1) lvls.push("L1 " + extra.modLevel1);
        if (extra.modLevel2) lvls.push("L2 " + extra.modLevel2);
        if (extra.modLevel3) lvls.push("L3 " + extra.modLevel3);
        if (extra.modLevel4) lvls.push("L4 " + extra.modLevel4);
        if (lvls.length) extraParts.push("Levels: " + lvls.join(" Â· "));
      }

      modalExtra.textContent = extraParts.join(" | ");

      // deck controls â€“ only in cards mode
      modalDeckControls.innerHTML = "";
      if (mode === "cards") {
        const deck = decks[activeDeckIndex];
        const current = deck.cards[cardId] || 0;
        const isNamed = card.type && card.type.startsWith("Named");
        const maxCopies = isNamed ? 1 : 4;

        const label = document.createElement("span");
        label.textContent = `In deck: ${current} / ${maxCopies}`;

        const plusBtn = document.createElement("button");
        plusBtn.className = "deck-btn";
        plusBtn.textContent = "+";
        plusBtn.onclick = () => {
          changeDeckCardCount(cardId, +1);
          openModal(cardId); // refresh numbers
        };

        const minusBtn = document.createElement("button");
        minusBtn.className = "deck-btn";
        minusBtn.textContent = "âˆ’";
        minusBtn.onclick = () => {
          changeDeckCardCount(cardId, -1);
          openModal(cardId); // refresh numbers
        };

        modalDeckControls.appendChild(minusBtn);
        modalDeckControls.appendChild(label);
        modalDeckControls.appendChild(plusBtn);

        modalHint.textContent = "Use + / âˆ’ to adjust this card in your active deck.";
      } else {
        modalHint.textContent = "Precon Viewer mode: this popup is read-only.";
        modalDeckControls.textContent = "";
      }

      modalBackdrop.classList.remove("hidden");
    }

    function closeModal() {
      modalBackdrop.classList.add("hidden");
      modalCardId = null;
    }

    modalCloseBtn.addEventListener("click", closeModal);
    modalBackdrop.addEventListener("click", (e) => {
      if (e.target === modalBackdrop) closeModal();
    });

    // ---------- Filters & mode toggle ----------

    [searchInput, typeFilter, setFilter].forEach(el => {
      el.addEventListener("input", renderCards);
      el.addEventListener("change", renderCards);
    });

    function setMode(nextMode) {
      mode = nextMode;
      if (mode === "cards") {
        deckPanel.classList.remove("hidden");
        preconPanel.classList.add("hidden");
        modeCardsBtn.classList.add("active");
        modePreconsBtn.classList.remove("active");
      } else {
        deckPanel.classList.add("hidden");
        preconPanel.classList.remove("hidden");
        modeCardsBtn.classList.remove("active");
        modePreconsBtn.classList.add("active");
      }
      renderCards();
    }

    modeCardsBtn.addEventListener("click", () => setMode("cards"));
    modePreconsBtn.addEventListener("click", () => setMode("precons"));

    // ---------- Init ----------

    (async function init() {
      await loadData();
    })();
  </script>
</body>
</html>
